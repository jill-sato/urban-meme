plugins {
    // use regular java plugin
    // it provides built-in tasks for java
    // 'compileJava' 'JavaExec' 'jar'
    // see https://docs.gradle.org/current/userguide/java_plugin.html
    id 'java'

    // add a docker plugin
    id 'com.palantir.docker' version '0.13.0'
}

// force use of maven repositories
repositories {
    mavenCentral() // repo1.maven.org/maven2
    mavenLocal() // .m2
}

dependencies {
    // use for both compile and runtime (runtime inherits compile)
    // these dependencies and their transitive dependencies
    // will be copied to build/libs/lib
    // and added to the classpath when using "gradle run"
    compile 'org.glassfish.jersey.containers:jersey-container-grizzly2-http:2.13'
    compile 'org.glassfish.jersey.media:jersey-media-moxy:2.13'

    // not added to the runtime classpath
    // i.e won't be copied into build/libs/lib
    // and won't be added in the classpath when using "gradle run"
    compileOnly 'javax:javaee-web-api:7.0'

    testCompile 'junit:junit:4.12'
}

// define a custom task to copy src/main/webapp to build/webroot
// uses built-in Copy
task copyWebappResources(type: Copy) {
    from 'src/main/webapp'
    into 'build/webroot'
}
// add it as a dependency of built-in task 'processResources'
// so that we can define the resources below
processResources.dependsOn copyWebappResources


// define build/webroot as resources in the project
// this will implicitly add webroot to the jar
// and also to the runtime classpath for JavaExec ("run" task)
sourceSets {
    main {
        resources {
            srcDirs "build"
            include "webroot/**"
        }
    }
}

// define a custom task to copy all dependencies in the runtime classpath
// into build/libs/lib
// uses built-in Copy
task copyLibs(type: Copy) {
  from configurations.runtime
  into 'build/libs/lib'
}
// add it as a dependency of built-in task 'assemble'
copyLibs.dependsOn jar
assemble.dependsOn copyLibs


// default jar configuration
// set the main classpath
// add each jar under build/libs/lib into the classpath
jar {
  manifest {
    attributes ('Main-Class': 'org.github.urban.meme.Main',
                'Class-Path': configurations.runtime.files.collect { "lib/$it.name" }.join(' ')
               )
  } 
}

// define a custom task to run the app from command line
// uses task type JavaExec from java plugin
task run(type:JavaExec) {
   main = 'org.github.urban.meme.Main'
   classpath = sourceSets.main.runtimeClasspath
}
// add it as a dependency of compileJava
run.dependsOn compileJava

// pass -PdockerRegistry to tag the image for a specific docker registry
// otherwise just image is just a default name and docker tag a name later.
docker {
    if(project.hasProperty("dockerRegistry")) {
        name dockerRegistry+'/urban-meme'
    } else {
      name "urban-meme"
    }
    files 'docker/entrypoint.sh'
    copySpec.from("build/libs").into(".")
    dockerfile file('docker/Dockerfile')
}
docker.dependsOn assemble

// Build docker image
// % gradle clean docker

// push docker image to aws docker registry.
// add awk to path; authenticate to aws:
// %  export PATH=~/Library/Python/3.5/bin/:$PATH; aws ecr get-login --region us-west-2; run output of command
// push docker image
// % gradle clean dockerPush -PdockerRegistry="780245226102.dkr.ecr.us-west-2.amazonaws.com"
